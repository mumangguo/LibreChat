# LibreChat 记忆与上下文机制分析

## 1. 总体概览
LibreChat 将对话分成“短期上下文”和“长期记忆”两层：
- **短期上下文**：当前会话中尚未被截断的消息、系统指令以及工具结果。每次调用模型前都会根据 token 限额重排/裁剪。
- **长期记忆**：可选特性。若开启，会在调用模型前检索历史记忆并写入系统提示，在模型回复后还可把新事实写回记忆库。
- **外部上下文**：文件检索、Web/MCP 工具等提供实时数据；它们默认只影响本轮对话，不自动落库。

## 2. 短期上下文（即时对话窗口）
`AgentClient.buildMessages()` 负责把当前会话整理成模型可消费的消息：先排序消息、执行 `handleContextStrategy` 决定窗口，再生成 `payload`。其后再追加记忆（若有）。

```436:474:api/server/controllers/agents/client.js
    if (this.contextStrategy) {
      ({ payload, promptTokens, tokenCountMap, messages } = await this.handleContextStrategy({
        orderedMessages,
        formattedMessages,
      }));
    }
    ...
    const result = {
      tokenCountMap,
      prompt: payload,
      promptTokens,
      messages,
    };
    ...
    const withoutKeys = await this.useMemory();
    if (withoutKeys) {
      systemContent += `${memoryInstructions}\n\n# Existing memory about the user:\n${withoutKeys}`;
    }
```

若要自定义短期上下文，可实现新的 `contextStrategy`（如按角色过滤、按主题聚类）并在 Agent 初始化时注入。

## 3. 长期记忆（Memory Service）
当配置开启且用户有 `Permissions.MEMORIES` 权限时，`useMemory()` 会：
1. 校验用户与配置，决定是否启用记忆。
2. 根据 `appConfig.memory.agent` 加载专用 Agent，构造记忆所用模型与提示词。
3. 调用 `createMemoryProcessor` 得到 `withoutKeys`（注入系统提示的文本）和 `processMemory`（后续写回）。

```513:618:api/server/controllers/agents/client.js
  async useMemory() {
    const user = this.options.req.user;
    if (user.personalization?.memories === false) {
      return;
    }
    const hasAccess = await checkAccess({
      user,
      permissionType: PermissionTypes.MEMORIES,
      permissions: [Permissions.USE],
      getRoleByName,
    });
    if (!hasAccess) {
      return;
    }
    const appConfig = this.options.req.config;
    const memoryConfig = appConfig.memory;
    if (!memoryConfig || memoryConfig.disabled === true) {
      return;
    }
    ...
    const [withoutKeys, processMemory] = await createMemoryProcessor({
      userId,
      config,
      messageId,
      conversationId,
      memoryMethods: {
        setMemory,
        deleteMemory,
        getFormattedMemories,
      },
      res: this.options.res,
    });
    this.processMemory = processMemory;
    return withoutKeys;
  }
```

### 配置入口
- `librechat.yaml` / 管理面板中的 `memory` 节点：可设置 `agent.id/model/provider`、`tokenLimit`、`validKeys`、启停等。
- 权限由 `Permissions.MEMORIES` 控制，未授权用户不会触发记忆。
- `memoryMethods` 默认使用本地集合；若要接入自定义向量库，可在 `createMemoryProcessor` 注入新的实现。

## 4. 外部上下文注入（工具/MCP/Web 搜索）
即使未启用长期记忆，LibreChat 仍可通过工具把实时数据植入 prompt：
- `handleTools.js` 与 `ToolService.js` 会按 manifest 加载 Google、YouTube、文件搜索、MCP 等工具。
- 工具输出会被写入当前短期上下文（作为 ToolMessage 或附件），供模型在本轮对话中使用。
- 如需写入长期记忆，可在生成响应后手动调用 `this.processMemory` 并挑选重要事实写入。

## 5. 扩展建议
| 需求 | 关键入口 | 说明 |
| --- | --- | --- |
| 自定义短期窗口 | `contextStrategy` / `handleContextStrategy` | 可新增按角色、按权重等策略 |
| 新的长期记忆后端 | `memoryMethods` (`setMemory/getFormattedMemories`) | 替换为外部数据库或服务 |
| 记忆写入时机 | `this.processMemory` | 在生成回复后手动挑选内容写回 |
| 工具注入更多上下文 | `api/app/clients/tools` + `handleTools` | 新增 LangChain Tool 或 MCP 服务器 |

---
通过以上分层，LibreChat 实现了“短期窗口 + 可配置记忆 + 外部检索”三位一体的上下文体系，既能保持快速响应，又能按需引入持久记忆与实时数据。开发者可以针对不同层次分别扩展，而不会相互干扰。


